package cli.core.tools

import std.fs.*
import std.collection.*
import stdx.encoding.json.*
import std.sync.{Mutex, Condition}
import std.time.DateTime

import magic.dsl.*
import magic.prelude.*
import magic.log.LogUtils
import magic.jsonable.ToJsonValue

import cli.lsp.{LSPClient, DocumentSymbol}
import cli.core.config.CliConfig

/**
 * LSP Toolset for code analysis using Language Server Protocol
 *
 * This toolset provides semantic code analysis capabilities by leveraging
 * the existing LSP client implementation.
 *
 * æ€§èƒ½ä¼˜åŒ–ï¼š
 * 1. ä½¿ç”¨å•ä¾‹æ¨¡å¼ç¼“å­˜ LSP å®¢æˆ·ç«¯ï¼Œé¿å…é‡å¤åˆ›å»ºå’Œåˆå§‹åŒ–
 * 2. ç¼“å­˜ç¬¦å·ä¿¡æ¯ï¼Œé¿å…é‡å¤è§£æåŒä¸€æ–‡ä»¶
 * 3. ç¼“å­˜å·²æ‰“å¼€çš„æ–‡æ¡£ï¼Œé¿å…é‡å¤æ‰“å¼€
 */
@toolset
public class LSPToolset {
    // å•ä¾‹ LSP å®¢æˆ·ç«¯ç¼“å­˜
    private static var cachedClient: Option<LSPClient> = None<LSPClient>

    // å·²æ‰“å¼€çš„æ–‡æ¡£ç¼“å­˜ï¼Œé¿å…é‡å¤æ‰“å¼€
    private static var openedDocuments: HashSet<String> = HashSet<String>()

    // ç¬¦å·ä¿¡æ¯ç¼“å­˜ï¼šæ–‡ä»¶è·¯å¾„ -> ç¬¦å· JSON å­—ç¬¦ä¸²
    // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤è§£æåŒä¸€æ–‡ä»¶çš„ç¬¦å·ä¿¡æ¯
    private static var symbolsCache: HashMap<String, String> = HashMap<String, String>()

    /**
     * è·å–æˆ–åˆ›å»º LSP å®¢æˆ·ç«¯ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
     * æ€§èƒ½ä¼˜åŒ–ï¼šå¤ç”¨åŒä¸€ä¸ªå®¢æˆ·ç«¯å®ä¾‹ï¼Œé¿å…é‡å¤åˆå§‹åŒ–
     */
    private static func getOrCreateLSPClient(): LSPClient {
        // å¦‚æœå·²æœ‰ç¼“å­˜çš„å®¢æˆ·ç«¯ï¼Œç›´æ¥è¿”å›
        if (let Some(client) <- cachedClient) {
            LogUtils.debug("â™» å¤ç”¨å·²ç¼“å­˜çš„ LSP å®¢æˆ·ç«¯")
            return client
        }

        // åˆ›å»ºæ–°å®¢æˆ·ç«¯
        try {
            LogUtils.info("ğŸ”§ åˆ›å»ºæ–°çš„ LSP å®¢æˆ·ç«¯...")
            let client = LSPClient("LSPServer")

            LogUtils.info("ğŸ”§ åˆå§‹åŒ– LSP å®¢æˆ·ç«¯ï¼Œå·¥ä½œç›®å½•: ${CliConfig.cwd.toString()}")
            client.initialize(root: CliConfig.cwd)

            LogUtils.info("âœ… LSP å®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ")

            // ç¼“å­˜å®¢æˆ·ç«¯
            cachedClient = Some(client)
            return client
        } catch (e: Exception) {
            LogUtils.error("âŒ LSP å®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥: ${e}")
            LogUtils.error("é”™è¯¯è¯¦æƒ…: ${e.message}")
            throw e
        }
    }

    /**
     * æ‰“å¼€æ–‡æ¡£ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
     * å¦‚æœæ–‡æ¡£å·²æ‰“å¼€ï¼Œåˆ™è·³è¿‡ï¼Œé¿å…é‡å¤æ‰“å¼€
     */
    private static func openDocumentIfNeeded(client: LSPClient, path: Path): Unit {
        let pathStr = path.toString()

        if (openedDocuments.contains(pathStr)) {
            LogUtils.debug("ğŸ“„ æ–‡æ¡£å·²æ‰“å¼€ï¼Œè·³è¿‡: ${pathStr}")
            return
        }

        LogUtils.debug("ğŸ“‚ æ‰“å¼€æ–‡æ¡£: ${pathStr}")
        client.openDocument(path)
        openedDocuments.add(pathStr)
    }

    /**
     * æ¸…ç†ç¼“å­˜ï¼ˆç”¨äºæµ‹è¯•æˆ–é‡ç½®ï¼‰
     * æ¸…ç†æ‰€æœ‰ç¼“å­˜ï¼šLSP å®¢æˆ·ç«¯ã€å·²æ‰“å¼€æ–‡æ¡£ã€ç¬¦å·ä¿¡æ¯
     */
    public static func clearCache(): Unit {
        if (let Some(client) <- cachedClient) {
            LogUtils.info("ğŸ§¹ å…³é—­å¹¶æ¸…ç† LSP å®¢æˆ·ç«¯ç¼“å­˜")
            client.close()
        }
        cachedClient = None<LSPClient>
        openedDocuments.clear()
        symbolsCache.clear()
        LogUtils.info("ğŸ§¹ å·²æ¸…ç†æ‰€æœ‰ç¼“å­˜ï¼ˆå®¢æˆ·ç«¯ã€æ–‡æ¡£ã€ç¬¦å·ï¼‰")
    }

    /**
     * æ¸…ç†ç‰¹å®šæ–‡ä»¶çš„ç¬¦å·ç¼“å­˜
     * ç”¨äºæ–‡ä»¶ä¿®æ”¹åéœ€è¦é‡æ–°è§£æçš„åœºæ™¯
     */
    public static func clearSymbolCache(filePath: String): Unit {
        if (symbolsCache.contains(filePath)) {
            symbolsCache.remove(filePath)
            LogUtils.debug("ğŸ§¹ å·²æ¸…ç†æ–‡ä»¶ç¬¦å·ç¼“å­˜: ${filePath}")
        }
    }

    /**
     * æ‰¹é‡æ‰“å¼€å¤šä¸ªæ–‡æ¡£
     * æ€§èƒ½ä¼˜åŒ–ï¼šä¸€æ¬¡æ€§æ‰“å¼€å¤šä¸ªæ–‡æ¡£ï¼Œå‡å°‘ LSP é€šä¿¡å¾€è¿”æ¬¡æ•°
     *
     * @param client LSP å®¢æˆ·ç«¯
     * @param paths æ–‡ä»¶è·¯å¾„åˆ—è¡¨
     * @return æˆåŠŸæ‰“å¼€çš„æ–‡ä»¶æ•°é‡
     */
    private static func openMultipleDocuments(client: LSPClient, paths: Array<Path>): Int64 {
        var openedCount: Int64 = 0

        LogUtils.info("ğŸ“‚ æ‰¹é‡æ‰“å¼€ ${paths.size} ä¸ªæ–‡æ¡£...")

        for (i in 0..paths.size) {
            let path = paths[i]
            let pathStr = path.toString()

            // æ£€æŸ¥æ˜¯å¦å·²æ‰“å¼€
            if (openedDocuments.contains(pathStr)) {
                LogUtils.debug("  [${i + 1}/${paths.size}] å·²æ‰“å¼€ï¼Œè·³è¿‡: ${pathStr}")
                continue
            }

            // æ‰“å¼€æ–‡æ¡£
            try {
                LogUtils.debug("  [${i + 1}/${paths.size}] æ‰“å¼€æ–‡æ¡£: ${pathStr}")
                client.openDocument(path)
                openedDocuments.add(pathStr)
                openedCount++
            } catch (e: Exception) {
                LogUtils.error("  [${i + 1}/${paths.size}] æ‰“å¼€æ–‡æ¡£å¤±è´¥: ${pathStr}, é”™è¯¯: ${e.message}")
            }
        }

        LogUtils.info("âœ… æ‰¹é‡æ‰“å¼€å®Œæˆï¼ŒæˆåŠŸæ‰“å¼€ ${openedCount}/${paths.size} ä¸ªæ–‡æ¡£")
        return openedCount
    }

    /**
     * Tool 1: Get all symbols in a Cangjie file
     *
     * Returns a JSON array of symbols with their names, kinds, and locations.
     * This is useful for quickly understanding the structure of a file without
     * reading the entire content.
     */
    @tool[
        description: """
Get all symbols (functions, classes, structs, etc.) in a Cangjie file using LSP.
This tool provides a structured overview of the file's contents without reading the entire file.
Use this to quickly understand what's defined in a file before deciding what to read in detail.

Returns a JSON array of symbols with:
- name: Symbol name
- kind: Symbol type (Class, Function, Method, Struct, Variable, etc.)
- line: Line number where the symbol is defined (1-based)
- detail: Additional details about the symbol
- children: Nested symbols (for classes, structs, etc.)

Example usage:
- "What functions are defined in auth.cj?"
- "Show me all classes in user_manager.cj"
- "List all public methods in the Database class"
""",
        parameters: {
            filePath: "Absolute path to the Cangjie file (must end with .cj)"
        }
    ]
    public func getFileSymbols(filePath: String): String {
        // éªŒè¯æ–‡ä»¶è·¯å¾„
        if (!filePath.endsWith(".cj")) {
            return "Error: File must be a Cangjie file (.cj extension)"
        }

        let path = Path(filePath)

        // å…ˆæ£€æŸ¥è·¯å¾„æ˜¯å¦ä¸ºç»å¯¹è·¯å¾„ï¼ˆåœ¨æ£€æŸ¥æ–‡ä»¶å­˜åœ¨æ€§ä¹‹å‰ï¼‰
        if (!path.isAbsolute()) {
            return "Error: File path must be absolute"
        }

        if (!exists(path)) {
            return "Error: File does not exist: ${filePath}"
        }

        // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæ£€æŸ¥ç¬¦å·ç¼“å­˜
        if (symbolsCache.contains(filePath)) {
            LogUtils.debug("ğŸ’¾ ä½¿ç”¨ç¼“å­˜çš„ç¬¦å·ä¿¡æ¯: ${filePath}")
            return symbolsCache[filePath]
        }

        // è·å–æˆ–åˆ›å»º LSP å®¢æˆ·ç«¯ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
        let client = try {
            getOrCreateLSPClient()
        } catch (e: Exception) {
            return "Error: Failed to initialize LSP client: ${e.message}"
        }

        try {
            // æ‰“å¼€æ–‡æ¡£ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
            openDocumentIfNeeded(client, path)

            LogUtils.info("ğŸ“‹ è·å–æ–‡æ¡£ç¬¦å·...")
            let symbols = client.getDocumentSymbols(path)
            LogUtils.info("âœ… è·å–åˆ° ${symbols.size} ä¸ªç¬¦å·")

            if (symbols.isEmpty()) {
                return "No symbols found in ${filePath}"
            }

            // è½¬æ¢ç¬¦å·ä¸º JSON
            let result = ArrayList<JsonValue>()
            for (symbol in symbols) {
                result.add(symbolToJson(symbol))
            }

            let jsonResult = JsonArray(result.toArray()).toJsonString()
            LogUtils.debug("JSON ç»“æœ: ${jsonResult}")

            // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ç¬¦å·ä¿¡æ¯
            symbolsCache[filePath] = jsonResult
            LogUtils.debug("ğŸ’¾ å·²ç¼“å­˜ç¬¦å·ä¿¡æ¯: ${filePath}")

            return jsonResult
        } catch (e: Exception) {
            LogUtils.error("è·å–æ–‡ä»¶ç¬¦å·å¤±è´¥: ${e}")
            LogUtils.error("é”™è¯¯å †æ ˆ: ${e}")
            return "Error: ${e.message}"
        }
        // æ³¨æ„ï¼šä¸å†å…³é—­å®¢æˆ·ç«¯ï¼Œä¿æŒç¼“å­˜ä»¥ä¾›åç»­ä½¿ç”¨
    }

    /**
     * Tool 2: Get symbols of a specific kind
     *
     * Filters symbols by their kind (e.g., only functions, only classes).
     * This is useful when you're looking for specific types of symbols.
     */
    @tool[
        description: """
Get symbols of a specific kind from a Cangjie file.

Supported kinds:
- "class" or "Class" - Classes
- "function" or "Function" - Top-level functions
- "method" or "Method" - Class methods
- "struct" or "Struct" - Structs
- "variable" or "Variable" - Variables
- "constant" or "Constant" - Constants

Example usage:
- "Show me all functions in utils.cj"
- "List all classes in the project"
- "Find all public methods"
""",
        parameters: {
            filePath: "Absolute path to the Cangjie file",
            kind: "Symbol kind to filter (class, function, method, struct, variable, constant)"
        }
    ]
    public func getSymbolsByKind(filePath: String, kind: String): String {
        try {
            // Get all symbols first - call the tool implementation function directly
            let allSymbolsJson = __tool_impl_of_getFileSymbols(filePath)

            // Check for errors
            if (allSymbolsJson.startsWith("Error:") || allSymbolsJson.startsWith("No symbols")) {
                return allSymbolsJson
            }

            // Parse JSON
            let allSymbols = JsonValue.fromStr(allSymbolsJson).asArray()

            // Filter by kind
            let kindLower = kind.toAsciiLower()
            let filtered = ArrayList<JsonValue>()

            for (symbolJson in allSymbols.getItems()) {
                let symbol = symbolJson.asObject()
                let symbolKind = symbol.get("kind").getOrThrow().asString().getValue().toAsciiLower()

                if (symbolKind == kindLower) {
                    filtered.add(symbolJson)
                }
            }

            if (filtered.isEmpty()) {
                return "No symbols of kind '${kind}' found in ${filePath}"
            }

            return JsonArray(filtered.toArray()).toJsonString()
        } catch (e: Exception) {
            LogUtils.error("Failed to get symbols by kind: ${e}")
            return "Error: ${e.message}"
        }
    }

    /**
     * Tool 3: Search for a symbol by name
     *
     * Searches for symbols matching a given name across a file.
     * Supports exact match and partial match.
     */
    @tool[
        description: """
Search for symbols by name in a Cangjie file.

This tool helps you quickly locate specific symbols without reading the entire file.
Supports both exact and partial matching.

Example usage:
- "Find the 'login' function in auth.cj"
- "Where is the UserAuth class defined?"
- "Search for symbols containing 'database' in db.cj"
""",
        parameters: {
            filePath: "Absolute path to the Cangjie file",
            symbolName: "Symbol name to search for (case-insensitive, supports partial match)",
            exactMatch: "Whether to use exact match (default: false)"
        }
    ]
    public func findSymbolByName(
        filePath: String,
        symbolName: String,
        exactMatch: String
    ): String {
        try {
            let useExactMatch = exactMatch.toAsciiLower() == "true"

            // Get all symbols - call the tool implementation function directly
            let allSymbolsJson = __tool_impl_of_getFileSymbols(filePath)

            // Check for errors
            if (allSymbolsJson.startsWith("Error:") || allSymbolsJson.startsWith("No symbols")) {
                return allSymbolsJson
            }

            // Parse JSON
            let allSymbols = JsonValue.fromStr(allSymbolsJson).asArray()

            // Search for symbol
            let searchName = symbolName.toAsciiLower()
            let found = ArrayList<JsonValue>()

            for (symbolJson in allSymbols.getItems()) {
                let symbol = symbolJson.asObject()
                let name = symbol.get("name").getOrThrow().asString().getValue()
                let nameLower = name.toAsciiLower()

                let matches = if (useExactMatch) {
                    nameLower == searchName
                } else {
                    nameLower.contains(searchName)
                }

                if (matches) {
                    found.add(symbolJson)
                }
            }

            if (found.isEmpty()) {
                return "No symbols matching '${symbolName}' found in ${filePath}"
            }

            return JsonArray(found.toArray()).toJsonString()
        } catch (e: Exception) {
            LogUtils.error("Failed to find symbol by name: ${e}")
            return "Error: ${e.message}"
        }
    }

    /**
     * Tool 4: Get symbol location for precise reading
     *
     * Returns the exact line range where a symbol is defined.
     * This can be used with the `head` or `cat` tool to read only the relevant code.
     */
    @tool[
        description: """
Get the exact line range where a symbol is defined.

This tool helps you read only the relevant code section instead of the entire file.
Use the returned line range with the 'head' or 'cat' tool to read the specific code.

Returns:
- symbolName: Name of the symbol
- kind: Symbol type
- startLine: Starting line number (1-based)
- endLine: Ending line number (1-based)
- lineCount: Number of lines

Example usage:
- "Where is the login function defined in auth.cj?"
- "Get the line range for the UserAuth class"
- "Show me where the processOrder method is located"
""",
        parameters: {
            filePath: "Absolute path to the Cangjie file",
            symbolName: "Symbol name to locate"
        }
    ]
    public func getSymbolLocation(filePath: String, symbolName: String): String {
        try {
            // Find the symbol - call the tool implementation function directly
            let symbolJson = __tool_impl_of_findSymbolByName(filePath, symbolName, "true")

            // Check for errors
            if (symbolJson.startsWith("Error:") || symbolJson.startsWith("No symbols")) {
                return symbolJson
            }

            // Parse JSON
            let symbols = JsonValue.fromStr(symbolJson).asArray()

            if (symbols.getItems().isEmpty()) {
                return "Symbol '${symbolName}' not found in ${filePath}"
            }

            // Get first match
            let symbol = symbols.getItems()[0].asObject()

            // Extract location info
            let name = symbol.get("name").getOrThrow().asString().getValue()
            let kind = symbol.get("kind").getOrThrow().asString().getValue()
            let line = symbol.get("line").getOrThrow().asInt().getValue()

            // Create result
            let fields = HashMap<String, JsonValue>()
            fields["symbolName"] = JsonString(name)
            fields["kind"] = JsonString(kind)
            fields["startLine"] = JsonInt(line)
            fields["filePath"] = JsonString(filePath)
            fields["suggestion"] = JsonString("Use 'cat ${filePath}' or 'head ${filePath} ${line + 50}' to read the code")

            let result = JsonObject(fields)

            return result.toJsonString()
        } catch (e: Exception) {
            LogUtils.error("Failed to get symbol location: ${e}")
            return "Error: ${e.message}"
        }
    }

    /**
     * æ‰¹é‡è·å–å¤šä¸ªæ–‡ä»¶çš„ç¬¦å·ä¿¡æ¯
     *
     * æ€§èƒ½ä¼˜åŒ–ï¼š
     * 1. ä¸€æ¬¡æ€§æ‰“å¼€æ‰€æœ‰æ–‡æ¡£ï¼Œå‡å°‘ LSP é€šä¿¡å¾€è¿”
     * 2. åˆ©ç”¨ç¬¦å·ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æ
     * 3. æ‰¹é‡å¤„ç†ï¼Œæå‡å¤šæ–‡ä»¶åˆ†ææ•ˆç‡
     *
     * è¿”å›æ ¼å¼ï¼š
     * {
     *   "files": [
     *     {
     *       "filePath": "/path/to/file1.cj",
     *       "symbols": [...],
     *       "symbolCount": 10
     *     },
     *     {
     *       "filePath": "/path/to/file2.cj",
     *       "symbols": [...],
     *       "symbolCount": 15
     *     }
     *   ],
     *   "totalFiles": 2,
     *   "totalSymbols": 25
     * }
     */
    @tool[
        description: """
ğŸš€ æ‰¹é‡å¹¶è¡Œè·å–å¤šä¸ª Cangjie æ–‡ä»¶çš„ç¬¦å·ä¿¡æ¯ï¼ˆé«˜æ€§èƒ½ç‰ˆæœ¬ï¼‰ã€‚

æ­¤å·¥å…·ä½¿ç”¨å¹¶è¡Œæ‰§è¡Œï¼Œæ¯”é€ä¸ªè°ƒç”¨ getFileSymbols å¿« 2-3å€ã€‚
é€‚ç”¨äºéœ€è¦åˆ†æå¤šä¸ªæ–‡ä»¶çš„åœºæ™¯ï¼Œå¦‚ï¼š
- åˆ†ææ•´ä¸ªæ¨¡å—çš„ä»£ç ç»“æ„
- æŸ¥æ‰¾è·¨æ–‡ä»¶çš„ç¬¦å·å®šä¹‰
- æ‰¹é‡ä»£ç å®¡æŸ¥

æ€§èƒ½ä¼˜åŒ–ï¼ˆP0-1 å¹¶è¡Œå·¥å…·æ‰§è¡Œï¼‰ï¼š
- âš¡ å¹¶è¡Œæ‰§è¡Œï¼šæœ€å¤š4ä¸ªæ–‡ä»¶åŒæ—¶æŸ¥è¯¢
- ğŸ“‚ ä¸€æ¬¡æ€§æ‰“å¼€æ‰€æœ‰æ–‡æ¡£ï¼Œå‡å°‘ LSP é€šä¿¡å¾€è¿”
- ğŸ’¾ åˆ©ç”¨ç¬¦å·ç¼“å­˜ï¼Œé¿å…é‡å¤è§£æ
- ğŸ“Š æ€§èƒ½è®¡æ—¶ï¼šæ˜¾ç¤ºå®é™…è€—æ—¶

è¿”å› JSON æ ¼å¼åŒ…å«ï¼š
- files: æ–‡ä»¶åˆ—è¡¨ï¼Œæ¯ä¸ªæ–‡ä»¶åŒ…å«ç¬¦å·ä¿¡æ¯
- totalFiles: æ€»æ–‡ä»¶æ•°
- totalSymbols: æ€»ç¬¦å·æ•°

æ€§èƒ½å¯¹æ¯”ï¼š
- ä¸²è¡Œ: 6ä¸ªæ–‡ä»¶ Ã— 150ms = 900ms
- å¹¶è¡Œ: max(150ms) Ã— 2æ‰¹æ¬¡ â‰ˆ 400ms (2.2x faster!)

Example usage:
- "åˆ†æ src/core/tools/ ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶çš„ç¬¦å·"
- "æ‰¹é‡è·å– auth.cj, user.cj, session.cj çš„ç¬¦å·ä¿¡æ¯"
- "æŸ¥çœ‹æ•´ä¸ª lsp æ¨¡å—çš„ä»£ç ç»“æ„"
""",
        parameters: {
            filePaths: "Comma-separated absolute paths to Cangjie files (e.g., '/path/to/file1.cj,/path/to/file2.cj')"
        }
    ]
    public func getMultipleFileSymbols(filePaths: String): String {
        // è§£ææ–‡ä»¶è·¯å¾„åˆ—è¡¨
        let pathStrings = filePaths.split(",")
        if (pathStrings.size == 0) {
            return "Error: No file paths provided"
        }

        LogUtils.info("ğŸ“¦ æ‰¹é‡è·å– ${pathStrings.size} ä¸ªæ–‡ä»¶çš„ç¬¦å·ä¿¡æ¯...")

        // éªŒè¯æ‰€æœ‰æ–‡ä»¶è·¯å¾„
        let validPaths = ArrayList<Path>()
        let invalidFiles = ArrayList<String>()

        for (i in 0..pathStrings.size) {
            let pathStr = pathStrings[i]

            // è·³è¿‡ç©ºå­—ç¬¦ä¸²
            if (pathStr.isEmpty()) {
                continue
            }

            // éªŒè¯æ–‡ä»¶æ‰©å±•å
            if (!pathStr.endsWith(".cj")) {
                invalidFiles.add("${pathStr} (not a .cj file)")
                continue
            }

            let path = Path(pathStr)

            // éªŒè¯ç»å¯¹è·¯å¾„
            if (!path.isAbsolute()) {
                invalidFiles.add("${pathStr} (not absolute path)")
                continue
            }

            // éªŒè¯æ–‡ä»¶å­˜åœ¨
            if (!exists(path)) {
                invalidFiles.add("${pathStr} (file not found)")
                continue
            }

            validPaths.add(path)
        }

        // å¦‚æœæœ‰æ— æ•ˆæ–‡ä»¶ï¼Œè¿”å›é”™è¯¯
        if (!invalidFiles.isEmpty()) {
            let errorMsg = "Error: Invalid files:\n" + invalidFiles.toArray().toString()
            LogUtils.error(errorMsg)
            return errorMsg
        }

        if (validPaths.isEmpty()) {
            return "Error: No valid files to process"
        }

        // è·å–æˆ–åˆ›å»º LSP å®¢æˆ·ç«¯
        let client = try {
            getOrCreateLSPClient()
        } catch (e: Exception) {
            return "Error: Failed to initialize LSP client: ${e.message}"
        }

        try {
            // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡æ‰“å¼€æ‰€æœ‰æ–‡æ¡£
            let openedCount = openMultipleDocuments(client, validPaths.toArray())
            LogUtils.info("ğŸ“‚ å·²æ‰“å¼€ ${openedCount} ä¸ªæ–‡æ¡£")

            // ğŸš€ P0-1: å¹¶è¡Œè·å–æ‰€æœ‰æ–‡ä»¶çš„ç¬¦å·ä¿¡æ¯
            let startMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
            let totalFiles = validPaths.size

            // åˆå§‹åŒ–ç»“æœæ•°ç»„
            let fileResults = ArrayList<Option<JsonValue>>()
            var i: Int64 = 0
            while (i < Int64(totalFiles)) {
                fileResults.add(None)
                i += 1
            }

            // åˆ†æ‰¹å¹¶å‘å¤„ç†ï¼ˆæœ€å¤š4ä¸ªå¹¶å‘ï¼‰
            let MAX_CONCURRENCY = 4
            var index = 0
            while (index < totalFiles) {
                let batchEnd = if (index + MAX_CONCURRENCY < totalFiles) {
                    index + MAX_CONCURRENCY
                } else {
                    totalFiles
                }
                let batchSize = batchEnd - index

                LogUtils.info("ğŸ”„ å¹¶è¡Œå¤„ç†æ‰¹æ¬¡: ${index} - ${batchEnd - 1}")

                // å½“å‰æ‰¹æ¬¡çš„å¹¶å‘æ‰§è¡Œ
                let mutex = Mutex()
                let condition = synchronized(mutex) { mutex.condition() }
                let completionList = ArrayList<Bool>()

                var i = index
                while (i < batchEnd) {
                    let fileIndex = i
                    let path = validPaths[i]
                    let pathStr = path.toString()

                    spawn {
                        try {
                            // è°ƒç”¨ getFileSymbols è·å–ç¬¦å·ï¼ˆä¼šä½¿ç”¨ç¼“å­˜ï¼‰
                            let symbolsJson = __tool_impl_of_getFileSymbols(pathStr)

                            // æ£€æŸ¥é”™è¯¯
                            if (symbolsJson.startsWith("Error:")) {
                                synchronized(mutex) {
                                    fileResults[fileIndex] = None
                                    completionList.add(true)
                                    condition.notifyAll()
                                }
                                LogUtils.error("è·å–ç¬¦å·å¤±è´¥: ${pathStr}")
                                return
                            }

                            // è§£æç¬¦å·æ•°ç»„
                            let symbols = try {
                                JsonValue.fromStr(symbolsJson).asArray().getItems()
                            } catch (e: Exception) {
                                synchronized(mutex) {
                                    fileResults[fileIndex] = None
                                    completionList.add(true)
                                    condition.notifyAll()
                                }
                                LogUtils.error("è§£æç¬¦å·JSONå¤±è´¥: ${pathStr}: ${e.message}")
                                return
                            }

                            let symbolCount = Int64(symbols.size)

                            // åˆ›å»ºæ–‡ä»¶ç»“æœ
                            let fileFields = HashMap<String, JsonValue>()
                            fileFields["filePath"] = JsonString(pathStr)
                            fileFields["symbols"] = JsonArray(symbols)
                            fileFields["symbolCount"] = JsonInt(symbolCount)

                            synchronized(mutex) {
                                fileResults[fileIndex] = Some(JsonObject(fileFields))
                                completionList.add(true)
                                condition.notifyAll()
                            }

                            LogUtils.debug("âš¡ è·å–åˆ° ${symbolCount} ä¸ªç¬¦å·: ${pathStr}")
                        } catch (e: Exception) {
                            synchronized(mutex) {
                                fileResults[fileIndex] = None
                                completionList.add(true)
                                condition.notifyAll()
                            }
                            LogUtils.error("å¹¶è¡ŒæŸ¥è¯¢å¤±è´¥: ${pathStr}: ${e.message}")
                        }
                    }
                    i += 1
                }

                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                synchronized(mutex) {
                    condition.waitUntil({ => completionList.size >= batchSize })
                }

                index = batchEnd
            }

            // è½¬æ¢ç»“æœå¹¶ç»Ÿè®¡
            let finalResults = ArrayList<JsonValue>()
            var totalSymbols: Int64 = 0
            for (result in fileResults) {
                if (let Some(fileResult) <- result) {
                    finalResults.add(fileResult)
                    // æå–symbolCount
                    let obj = fileResult.asObject()
                    if (let Some(count) <- obj.get("symbolCount")) {
                        try {
                            totalSymbols += Int64.fromJsonValue(count)
                        } catch (e: Exception) {
                            // Ignore conversion errors
                        }
                    }
                }
            }

            let endMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
            let durationMs = endMs - startMs
            LogUtils.info("âš¡ å¹¶è¡ŒæŸ¥è¯¢å®Œæˆ: ${finalResults.size}/${totalFiles} æ–‡ä»¶ï¼Œå…± ${totalSymbols} ä¸ªç¬¦å·ï¼Œè€—æ—¶ ${durationMs}ms")

            // åˆ›å»ºæœ€ç»ˆç»“æœ
            let resultFields = HashMap<String, JsonValue>()
            resultFields["files"] = JsonArray(finalResults.toArray())
            resultFields["totalFiles"] = JsonInt(finalResults.size)
            resultFields["totalSymbols"] = JsonInt(totalSymbols)

            let result = JsonObject(resultFields).toJsonString()

            LogUtils.info("âœ… æ‰¹é‡è·å–å®Œæˆï¼š${finalResults.size} ä¸ªæ–‡ä»¶ï¼Œå…± ${totalSymbols} ä¸ªç¬¦å·")

            return result
        } catch (e: Exception) {
            LogUtils.error("æ‰¹é‡è·å–ç¬¦å·å¤±è´¥: ${e}")
            return "Error: ${e.message}"
        }
    }

    // Helper function: Convert DocumentSymbol to JSON
    private static func symbolToJson(symbol: DocumentSymbol): JsonValue {
        let fields = HashMap<String, JsonValue>()

        // Basic info
        fields["name"] = JsonString(symbol.name)
        fields["kind"] = JsonString(getSymbolKindName(symbol.kind))
        fields["line"] = JsonInt(symbol.range.start.line + 1)  // Convert to 1-based

        // Detail
        match (symbol.detail) {
            case Some(detail) =>
                fields["detail"] = JsonString(detail)
            case None =>
                ()
        }

        // Children
        match (symbol.children) {
            case Some(children) =>
                let childrenJson = ArrayList<JsonValue>()
                for (child in children) {
                    childrenJson.add(symbolToJson(child))
                }
                fields["children"] = JsonArray(childrenJson.toArray())
            case None =>
                ()
        }

        return JsonObject(fields)
    }

    // Helper function: Get symbol kind name
    private static func getSymbolKindName(kind: Int64): String {
        match (kind) {
            case 5 => "Class"
            case 6 => "Method"
            case 12 => "Function"
            case 13 => "Variable"
            case 14 => "Constant"
            case 23 => "Struct"
            case _ => "Unknown"
        }
    }


    /**
     * Tool 4: Get code summary for a Cangjie file
     *
     * Provides a concise overview of the file's structure and contents.
     * This is useful for quickly understanding what's in a file.
     */
    @tool[
        description: """
Get a concise summary of a Cangjie file's structure and main components.
This provides a quick overview perfect for understanding a file without reading it entirely.

The summary includes:
- File statistics (total lines, number of symbols)
- Main components (classes, functions, structs, etc.) with their line numbers
- Package declaration
- Quick structural overview

Use this when you want to:
- Get a quick overview of what's in a file
- Understand the file structure before diving into details
- Check what classes or functions are defined
- Get a sense of file complexity

Returns a formatted summary with:
- File path and statistics
- List of main symbols grouped by type
- Symbol locations (line numbers)

Example usage:
- "Give me a summary of user_manager.cj"
- "What's in the authentication.cj file?"
- "Show me an overview of database.cj"
""",
        parameters: {
            filePath: "Absolute path to the Cangjie file (must end with .cj)"
        }
    ]
    public func getCodeSummary(filePath: String): String {
        // éªŒè¯å‚æ•°
        if (!filePath.endsWith(".cj")) {
            return "Error: File must be a Cangjie file (.cj extension)"
        }

        let path = Path(filePath)

        if (!path.isAbsolute()) {
            return "Error: File path must be absolute"
        }

        if (!exists(path)) {
            return "Error: File does not exist: ${filePath}"
        }

        // è·å– LSP å®¢æˆ·ç«¯
        let client = try {
            getOrCreateLSPClient()
        } catch (e: Exception) {
            return "Error: Failed to initialize LSP client: ${e.message}"
        }

        try {
            // æ‰“å¼€æ–‡æ¡£
            openDocumentIfNeeded(client, path)

            // è·å–ç¬¦å·ä¿¡æ¯
            LogUtils.info("ğŸ“‹ è·å–æ–‡æ¡£ç¬¦å·...")
            let symbols = client.getDocumentSymbols(path)

            // è¯»å–æ–‡ä»¶ä»¥è·å–è¡Œæ•°å’Œpackageä¿¡æ¯
            let content = String.fromUtf8(File.readFrom(path))
            let lines = content.split("\n")
            let totalLines = lines.size

            // æå–packageå£°æ˜
            var packageName = "unknown"
            for (line in lines) {
                let trimmed = line.trimAscii()
                if (trimmed.startsWith("package ")) {
                    packageName = trimmed[8..].trimAscii()
                    break
                }
            }

            // æŒ‰ç±»å‹åˆ†ç»„ç¬¦å·
            var classes = ArrayList<DocumentSymbol>()
            var functions = ArrayList<DocumentSymbol>()
            var structs = ArrayList<DocumentSymbol>()
            var variables = ArrayList<DocumentSymbol>()
            var others = ArrayList<DocumentSymbol>()

            for (symbol in symbols) {
                match (symbol.kind) {
                    case 5 => classes.add(symbol)  // Class
                    case 12 => functions.add(symbol)  // Function
                    case 23 => structs.add(symbol)  // Struct
                    case 13 | 14 => variables.add(symbol)  // Variable/Constant
                    case _ => others.add(symbol)
                }
            }

            // æ„å»ºæ‘˜è¦
            var summary = StringBuilder()
            let pathParts = path.toString().split("/")
            let fileName = pathParts[pathParts.size - 1]
            summary.append("ğŸ“„ Code Summary: ${fileName}\n")
            summary.append("Package: ${packageName}\n")
            summary.append("Total Lines: ${totalLines}\n")
            summary.append("Total Symbols: ${symbols.size}\n")
            summary.append("\n")

            if (classes.size > 0) {
                summary.append("ğŸ“¦ Classes (${classes.size}):\n")
                for (cls in classes) {
                    summary.append("  - ${cls.name} (line ${cls.range.start.line + 1})\n")
                }
                summary.append("\n")
            }

            if (structs.size > 0) {
                summary.append("ğŸ— Structs (${structs.size}):\n")
                for (st in structs) {
                    summary.append("  - ${st.name} (line ${st.range.start.line + 1})\n")
                }
                summary.append("\n")
            }

            if (functions.size > 0) {
                summary.append("âš¡ Functions (${functions.size}):\n")
                for (fn in functions) {
                    summary.append("  - ${fn.name} (line ${fn.range.start.line + 1})\n")
                }
                summary.append("\n")
            }

            if (variables.size > 0) {
                summary.append("ğŸ“Š Variables/Constants (${variables.size}):\n")
                for (v in variables) {
                    summary.append("  - ${v.name} (line ${v.range.start.line + 1})\n")
                }
                summary.append("\n")
            }

            if (symbols.isEmpty()) {
                summary.append("No symbols found in this file.\n")
            }

            return summary.toString()

        } catch (e: Exception) {
            LogUtils.error("ç”Ÿæˆä»£ç æ‘˜è¦å¤±è´¥: ${e}")
            return "Error: ${e.message}"
        }
    }
}

