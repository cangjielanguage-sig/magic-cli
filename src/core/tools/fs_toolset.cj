package cli.core.tools

import std.fs.*
import std.process.*
import std.io.*
import std.env.*
import std.posix.*
import std.collection.*
import std.regex.Regex
import std.sort.sort
import std.time.DateTime
import std.sync.{Mutex, AtomicInt64}
import stdx.encoding.json.*

import magic.dsl.*
import magic.prelude.*
import magic.log.LogUtils

import cli.utils.*
import cli.io.{InputUtils, PrintUtils, Confirmation}
import cli.core.tools.fs_utils.*
import cli.core.tools.code_compression.*
import cli.core.config.CliConfig


//==============================================================================
// CLAIM
// Some prompts in this file are copied from Gemini Cli
// https://github.com/google-gemini/gemini-cli/tree/main/packages/core/src/tools
//==============================================================================

let EDIT_FILE_DESCRIPTION = """
Replaces text within a file. By default, replaces a single occurrence.
This tool requires providing significant context around the change to ensure precise targeting. Always use the readFile tool to examine the file's current content before attempting a text replacement.

Expectation for required parameters:
1. path MUST be an absolute path; otherwise an error will be thrown.
2. oldContent MUST be the exact literal text to replace (including all whitespace, indentation, newlines, and surrounding code etc.).
3. newContent MUST be the exact literal text to replace `oldContent` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.
4. NEVER escape `oldContent` or `newContent`, that would break the exact literal text requirement.
**Important:** If ANY of the above are not satisfied, the tool will fail. CRITICAL for `oldContent`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail.
"""

/**
 * Check if line ending mismatch exists between oldContent and fileContent
 * Returns hint information without modifying content
 */
private func checkLineEndingMismatch(oldContent: String, fileContent: String): String {
    if (fileContent.contains("\r\n") && !oldContent.contains("\r\n")) {
        return "File uses Windows line endings (CRLF), but your content uses Unix (LF). Consider using \\r\\n instead of \\n."
    } else if (!fileContent.contains("\r\n") && oldContent.contains("\r\n")) {
        return "File uses Unix line endings (LF), but your content uses Windows (CRLF). Consider using \\n instead of \\r\\n."
    }
    return ""
}

//----------------------------------------------------------------------------------
// Read only tools
//----------------------------------------------------------------------------------

@tool[
    description: "Lists all files and subdirectories in a directory and returns the list",
    parameters: { path: "Directory path, must be an absolute path" }
]
func listDirectory(path: String): String {
    if (!Path(path).isAbsolute()) {
        return "Directory path must be absolute"
    }

    let message = path
    PrintUtils.printTool("List Directory", message)

    try {
        let (exitCode, stdout, stderr) = if (InfoUtils.os == "windows") {
            ShellUtils.execute(["dir"], workDir: Path(path))
        } else { //linux or ohos
            ShellUtils.execute(["ls", "-la"], workDir: Path(path))
        }

        if (exitCode == 0) {
            let outString = stdout.trimAscii()
            PrintUtils.printToolResult(outString)
            return "Directory contents:\n${outString}"
        } else {
            let errString = stderr.trimAscii()
            let result = "Failed to get directory contents, error output:\n${errString}"
            PrintUtils.printToolResult(result)
            return result
        }
    } catch (e: Exception) {
        PrintUtils.printToolResult("Failed to list directory")
        return "Failed to list directory: ${e}"
    }
}

@tool[
    description: "Reads and returns a specific range of lines from a file with line numbers. If startLine and endLine is omitted, the entire file will be read.",
    parameters: {
        filePath: "The absolute path to the file to read",
        startLine: "Optional: Starting line number (1-based, inclusive). If not provided, reads from start of file",
        endLine: "Optional: Ending line number (1-based, inclusive). If not provided, reads to end of file"
    }
]
func readFile(filePath: String, startLine: Option<Int64>, endLine: Option<Int64>): String {
    let start = startLine ?? 1
    let end = endLine.map { n => n.toString() } ?? "EOF"
    let message = "${filePath} (${start}-${end})"
    PrintUtils.printTool("Read File", message)
    var content = catRange(filePath, startLine ?? 1, endLine: endLine ?? Int64.Max)

    if (filePath.endsWith(".cj") && content.size > getCompressionThreshold(false)) {
        content = compressCode(filePath, startLine: startLine ?? 1, endLine: endLine ?? Int64.Max)
    }

    PrintUtils.printToolResult(content)
    return "<file-content path=${filePath} start=${start} end=${end}>\n${content}\n</file-content>"
}

@tool[
    description: 'Searches for a regular expression pattern within the content of files in a specified directory (or current working directory). Can filter files by a glob pattern. Returns the lines containing matches, along with their file paths and line numbers.',
    parameters: {
        pattern: "The regular expression (regex) pattern to search for within file contents (e.g., 'func \\s+foo', 'import\\s+\\{.*\\}\\s+.*').",
        path: "Optional: The absolute path to the directory to search within. If omitted, searches the current working directory.",
        fileType: "Optional: A glob pattern to filter which files are searched (e.g., '*.js', '*.{ts,tsx}', 'src/**'). If omitted, searches all files (respecting potential global ignores).",
    }
]
public func grepSearch(pattern: String, path: Option<String>, include: Option<String>): String {
    // Construct the info message
    let strBuilder = StringBuilder("pattern: ${pattern}")
    if (let Some(path) <- path) {
        strBuilder.append("\npath: ${path}")
    }
    if (let Some(include) <- include) {
        strBuilder.append("\ninclude: ${include}")
    }
    PrintUtils.printTool("Grep", strBuilder.toString())

    let result = grep(pattern, path, include)
    if (result.isEmpty()) {
        PrintUtils.printToolResult("Nothing found")
        return "Nothing found"
    } else {
        PrintUtils.printToolResult(result)
        return result
    }
}

// @tool[
//     description: "Lists the directory structure recursively from the given path, showing files and subdirectories in a tree-like format. Useful for understanding the overall layout and hierarchy of a project or folder.",
//     parameters: {
//         path: "The absolute path to the directory to visualize."
//     }
// ]
// public func tree(path: String): String {
//     PrintUtils.printTool("Tree", "path: ${path}")
//     return listTree(path)
// }

@tool[
    description: "Efficiently finds files matching specific extensions patterns (e.g., `src/**/*.ts`, `**/*.md`), returning absolute paths. Ideal for quickly locating files based on their extension name, especially in large codebases.",
    parameters: {
        pattern: "Glob pattern to match (e.g., '*.cj' for Cangjie files, '**/test*.cj' for test files recursively)",
        path: "Optional: absolute directory path to search in. Defaults to current working directory."
    }
]
public func globSearch(pattern: String, path: Option<String>): String {
    let searchPath = path ?? CliConfig.cwd.toString()
    if (!Path(searchPath).isAbsolute()) {
        return "Path must be absolute"
    }
    if (!exists(searchPath)) {
        return "Path does not exist: ${searchPath}"
    }

    let message = "pattern: ${pattern}\npath: ${searchPath}"
    PrintUtils.printTool("Glob Search", message)

    try {
        let results = glob(pattern, searchPath)

        if (results.isEmpty()) {
            PrintUtils.printToolResult("Nothing found")
            return "No files matching pattern '${pattern}' found"
        }

        let found = String.join(
            results |> map { file => "- ${file}" } |> collectArray,
            delimiter: "\n"
        )
        PrintUtils.printToolResult(found)
        return "Found ${results.size} matches:\n${found}"
    } catch (e: Exception) {
        return "Error during glob search: ${e}"
    }
}

/**
  * ğŸš€ P0-1: æ‰¹é‡å¹¶è¡Œè¯»å–å¤šä¸ªæ–‡ä»¶ï¼ˆçœŸå®å®ç°ï¼‰
  *
  * è‡ªåŠ¨ä½¿ç”¨å¹¶è¡Œæ‰§è¡Œè¯»å–å¤šä¸ªæ–‡ä»¶ï¼Œæå‡æ€§èƒ½
  *
  * @param filePaths æ–‡ä»¶è·¯å¾„æ•°ç»„
  * @return æ–‡ä»¶å†…å®¹æ•°ç»„ï¼ˆä¸è¾“å…¥é¡ºåºå¯¹åº”ï¼‰
  *
  * æ€§èƒ½ï¼š
  * - ä¸²è¡Œ: nä¸ªæ–‡ä»¶ Ã— 50ms = nÃ—50ms
  * - å¹¶è¡Œ: max(50ms) Ã— (n/4) â‰ˆ nÃ—12.5ms
  * - åŠ é€Ÿæ¯”: çº¦4xï¼ˆå°æ–‡ä»¶ï¼‰åˆ°2xï¼ˆå¤§æ–‡ä»¶ï¼‰
  */
@tool[
    description: """
ğŸš€ Batch read multiple files in parallel for maximum performance (2-4x faster than sequential reading).

This tool uses parallel execution (MAX_CONCURRENCY=4) to read multiple files simultaneously.

Use cases:
- Read configuration files at startup
- Load multiple source files for analysis
- Batch data processing

Performance:
- Small files (< 100KB): 4x faster
- Large files (> 1MB): 2x faster
- Recommended for 3+ files

Example usage:
- "ä½¿ç”¨batchReadFilesæ‰¹é‡è¯»å–ä»¥ä¸‹6ä¸ªæ–‡ä»¶ï¼š/path/to/file1.cj,/path/to/file2.cj,/path/to/file3.cj"
- "Read all config files: /project/config.toml,/project/settings.toml"

Returns: JSON object with file contents, status, and performance metrics.
""",
    parameters: {
        filePaths: "Comma-separated absolute file paths (e.g., '/path/file1.txt,/path/file2.txt'). Spaces around commas are trimmed automatically."
    }
]
public func batchReadFiles(filePaths: String): String {
    // è§£ææ–‡ä»¶è·¯å¾„åˆ—è¡¨
    let cleanPaths = filePaths.split(",") |>
        map { path => path.trimAscii() } |>
        filter { path => !path.isEmpty() } |>
        collectArray

    let message = String.join(cleanPaths, delimiter: "\n")
    PrintUtils.printTool("Batch Read Files", message)

    // Validate input
    if (cleanPaths.isEmpty()) {
        let errorResult = HashMap<String, JsonValue>()
        errorResult["error"] = JsonString("No file paths provided")
        errorResult["files"] = JsonArray([])
        return JsonObject(errorResult).toJsonString()
    }

    let totalFiles = cleanPaths.size

    let startMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
    LogUtils.info("[FSToolset] Batch reading ${totalFiles} files in parallel...")

    let results = ArrayList<Option<String>>(totalFiles, { i => None })

    // åˆ†æ‰¹å¹¶å‘å¤„ç†ï¼ˆæœ€å¤š4ä¸ªå¹¶å‘ï¼‰
    let MAX_CONCURRENCY = 4
    for (index in 0..totalFiles:MAX_CONCURRENCY) {
        let batchEnd = if (index + MAX_CONCURRENCY < totalFiles) {
            index + MAX_CONCURRENCY
        } else {
            totalFiles
        }
        let batchSize = batchEnd - index

        // å½“å‰æ‰¹æ¬¡çš„å¹¶å‘æ‰§è¡Œ
        let futures = ArrayList<Future<(Int64, String)>>()

        for (fileIndex in index..batchEnd) {
            let filePath = cleanPaths[fileIndex]
            let fut = spawn {
                try {
                    let content = String.fromUtf8(File.readFrom(filePath))
                    LogUtils.debug("[FSToolset] Parallel read: ${filePath} (${content.size} bytes)")
                    return (fileIndex, content)
                } catch (e: Exception) {
                    LogUtils.error("[FSToolset] Failed to read ${filePath}: ${e.message}")
                    return (fileIndex, "Error reading ${filePath}: ${e.message}")
                }
            }
            futures.add(fut)
        }
        // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
        for (fut in futures) {
            let (fileIndex, content) = fut.get()
            results[fileIndex] = content
        }
    }

    //code compression
    var totalChars = results.iterator().fold(0) { sum: Int, r: ?String => sum + (r?.size ?? 0) }
    for (i in 0..totalFiles) {
        if (totalChars <= getCompressionThreshold(true)) {
            break
        }
        if (cleanPaths[i].endsWith(".cj") && results[i].isSome()) {
            let old = results[i].getOrThrow().size
            results[i] = compressCode(cleanPaths[i])
            let new = results[i].getOrThrow().size
            totalChars += (new - old)
        }
    }

    // è½¬æ¢ç»“æœä¸ºJSONæ ¼å¼
    let fileResults = ArrayList<JsonValue>()
    var successCount: Int64 = 0

    for (i in 0..totalFiles) {
        let filePath = cleanPaths[i]
        let fileResult = HashMap<String, JsonValue>()
        fileResult["path"] = JsonString(filePath)

        if (let Some(content) <- results[i]) {
            if (content.startsWith("Error reading")) {
                fileResult["status"] = JsonString("error")
                fileResult["error"] = JsonString(content)
            } else {
                fileResult["status"] = JsonString("success")
                fileResult["content"] = JsonString(content)
                fileResult["size"] = JsonInt(Int64(content.size))
                successCount += 1
            }
        } else {
            fileResult["status"] = JsonString("error")
            fileResult["error"] = JsonString("Failed to read file")
        }

        fileResults.add(JsonObject(fileResult))
    }

    let endMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
    let durationMs = endMs - startMs
    LogUtils.info("[FSToolset] âš¡ Batch read completed: ${successCount}/${totalFiles} files in ${durationMs}ms")

    // æ„å»ºæœ€ç»ˆJSONç»“æœ
    let result = HashMap<String, JsonValue>()
    result["files"] = JsonArray(fileResults.toArray())
    result["totalFiles"] = JsonInt(totalFiles)
    result["successCount"] = JsonInt(successCount)
    result["failedCount"] = JsonInt(totalFiles - successCount)
    result["durationMs"] = JsonInt(durationMs)

    return JsonObject(result).toJsonString()
}

//----------------------------------------------------------------------------------

/**
 * Read-only file system tools
 */
@toolset[
    tools: [listDirectory, readFile, batchReadFiles, grepSearch, globSearch]
]
public class ReadOnlyFSToolset {
}

/**
 * General file system tools
 */
@toolset[
    tools: [listDirectory, readFile, batchReadFiles, grepSearch, globSearch]
]
public class FSToolset {
    @tool[
        description: "Creates a directory recursively and returns the creation result",
        parameters: { path: "Directory path, must be an absolute path" }
    ]
    public func createDirectory(path: String): String {
        if (!Path(path).isAbsolute()) {
            return "Directory path must be absolute"
        }

        let message = path
        if (InputUtils.confirm("Create Directory", message) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            Directory.create(path, recursive: true)
            return "Directory ${path} created successfully!"
        } catch (e: FSException) {
            return "Directory already exists"
        } catch (e: IllegalArgumentException) {
            return "Directory is empty, current directory, root directory, or contains null characters"
        } catch (e: Exception) {
            return "Failed to create directory: ${e}"
        }
    }

    @tool[
        description: "Creates a file with content and returns the creation result",
        parameters: {
            content: "File content",
            filePath: "File path, must be an absolute path"
        }
    ]
    public func createFile(content: String, filePath: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        if (InputUtils.confirm("Create File ${filePath}", content) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            let file = File(filePath, Write)
            file.write(content.toArray())
            file.close()
            return "File ${filePath} created successfully!"
        } catch (e: Exception) {
            return "Failed to create file: ${e}"
        }
    }

    @tool[
        description: "Deletes a file or directory recursively and returns the deletion result",
        parameters: { path: "File or directory path, must be an absolute path" }
    ]
    public func deleteFileOrDirectory(path: String): String {
        if (!Path(path).isAbsolute()) {
            return "File or directory path must be absolute"
        }

        let message = path
        if (InputUtils.confirm("Delete File or Directory", message) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            remove(path, recursive: true)
            return "File or directory ${path} deleted successfully!"
        } catch (e: FSException) {
            return "Specified directory does not exist or deletion failed"
        } catch (e: IllegalArgumentException) {
            return "Path is empty or contains null terminator"
        }
    }

    @tool[
        description: "Writes content to a single file and returns the write result",
        parameters: { filePath: "File path, must be an absolute path", content: "Content to write" }
    ]
    public func writeFile(filePath: String, content: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        let message = filePath + "\n" + content
        if (InputUtils.confirm("Write File", message) == Confirmation.Deny) {
            return "User denied the operation"
        }
        return writeFileBasic(filePath, content)
    }

    @tool[
        description: "${EDIT_FILE_DESCRIPTION}",
        parameters: {
            filePath: "File path, must be an absolute path",
            oldContent: "The exact literal text to replace, preferably unescaped. Including at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail.",
            newContent: "The exact literal text to replace `oldContent` with, preferably unescaped. Provide the EXACT text. newContent MUST be different from oldContent; otherwise, the tool will fail."
        }
    ]
    public func editFile(filePath: String, oldContent: String, newContent: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        try {
            let oldFileContent = String.fromUtf8(File.readFrom(filePath))

            if (!oldFileContent.contains(oldContent)) {
                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ¢è¡Œç¬¦ä¸åŒ¹é…é—®é¢˜
                let hint = " " + checkLineEndingMismatch(oldContent, oldFileContent)
                PrintUtils.printToolFailure(
                    "Edit File (${filePath})",
                    failureInfo: "File does not contain the specified content." + hint
                )
                return "Failed to edit. File ${filePath} does not contain the specified content '${oldContent}'." + hint
            }

            // ä½¿ç”¨åŸå§‹å†…å®¹è¿›è¡Œæ›¿æ¢
            let newFileContent = oldFileContent.replace(oldContent, newContent)
            if (oldFileContent == newFileContent) {
                PrintUtils.printToolFailure(
                    "Edit File (${filePath})",
                    failureInfo: "File content is not modified"
                )
                return "No changes to apply. The oldContent and newContent are identical in file: ${filePath}"
            }

            let message = diff(oldFileContent, newFileContent) |> PrintUtils.renderDiff

            if (InputUtils.confirm("Edit File (${filePath})", message) == Confirmation.Deny) {
                return "User denied the operation"
            }

            File.writeTo(filePath, newFileContent.toArray())
            return "File ${filePath} content modified successfully"
        } catch (ex: FSException) {
            return "File path error or file is not readable/writable"
        } catch (ex: IllegalArgumentException) {
            return "File path is empty or contains illegal characters"
        }
    }
}