package cli.core.tools

import std.fs.*
import std.process.*
import std.io.*
import std.env.*
import std.posix.*
import std.collection.*
import std.regex.Regex
import std.sort.sort
import std.time.DateTime
import std.sync.{Mutex, AtomicInt64}
import stdx.encoding.json.*

import magic.dsl.*
import magic.prelude.*
import magic.log.LogUtils

import cli.utils.*
import cli.io.{InputUtils, PrintUtils, Confirmation}
import cli.core.tools.fs_utils.*
import cli.core.config.CliConfig

//==============================================================================
// CLAIM
// Some prompts in this file are copied from Gemini Cli
// https://github.com/google-gemini/gemini-cli/tree/main/packages/core/src/tools
//==============================================================================

let EDIT_FILE_DESCRIPTION = """
Replaces text within a file. By default, replaces a single occurrence.
This tool requires providing significant context around the change to ensure precise targeting. Always use the readFile tool to examine the file's current content before attempting a text replacement.

Expectation for required parameters:
1. path MUST be an absolute path; otherwise an error will be thrown.
2. oldContent MUST be the exact literal text to replace (including all whitespace, indentation, newlines, and surrounding code etc.).
3. newContent MUST be the exact literal text to replace `oldContent` with (also including all whitespace, indentation, newlines, and surrounding code etc.). Ensure the resulting code is correct and idiomatic.
4. NEVER escape `oldContent` or `newContent`, that would break the exact literal text requirement.
**Important:** If ANY of the above are not satisfied, the tool will fail. CRITICAL for `oldContent`: Must uniquely identify the single instance to change. Include at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string matches multiple locations, or does not match exactly, the tool will fail.
"""

/**
 * Check if line ending mismatch exists between oldContent and fileContent
 * Returns hint information without modifying content
 */
private func checkLineEndingMismatch(oldContent: String, fileContent: String): String {
    if (fileContent.contains("\r\n") && !oldContent.contains("\r\n")) {
        return "File uses Windows line endings (CRLF), but your content uses Unix (LF). Consider using \\r\\n instead of \\n."
    } else if (!fileContent.contains("\r\n") && oldContent.contains("\r\n")) {
        return "File uses Unix line endings (LF), but your content uses Windows (CRLF). Consider using \\n instead of \\r\\n."
    }
    return ""
}

@toolset
public class FSToolset {
    @tool[
        description: "Creates a directory recursively and returns the creation result",
        parameters: { path: "Directory path, must be an absolute path" }
    ]
    public func createDirectory(path: String): String {
        if (!Path(path).isAbsolute()) {
            return "Directory path must be absolute"
        }

        let message = path
        if (InputUtils.confirm("Create Directory", message) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            Directory.create(path, recursive: true)
            return "Directory ${path} created successfully!"
        } catch (e: FSException) {
            return "Directory already exists"
        } catch (e: IllegalArgumentException) {
            return "Directory is empty, current directory, root directory, or contains null characters"
        } catch (e: Exception) {
            return "Failed to create directory: ${e}"
        }
    }

    @tool[
        description: "Creates a file with content and returns the creation result",
        parameters: {
            content: "File content",
            filePath: "File path, must be an absolute path"
        }
    ]
    public func createFile(content: String, filePath: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        if (InputUtils.confirm("Create File ${filePath}", content) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            let file = File(filePath, Write)
            file.write(content.toArray())
            file.close()
            return "File ${filePath} created successfully!"
        } catch (e: Exception) {
            return "Failed to create file: ${e}"
        }
    }

    @tool[
        description: "Deletes a file or directory recursively and returns the deletion result",
        parameters: { path: "File or directory path, must be an absolute path" }
    ]
    public func deleteFileOrDirectory(path: String): String {
        if (!Path(path).isAbsolute()) {
            return "File or directory path must be absolute"
        }

        let message = path
        if (InputUtils.confirm("Delete File or Directory", message) == Confirmation.Deny) {
            return "User denied the operation"
        }

        try {
            remove(path, recursive: true)
            return "File or directory ${path} deleted successfully!"
        } catch (e: FSException) {
            return "Specified directory does not exist or deletion failed"
        } catch (e: IllegalArgumentException) {
            return "Path is empty or contains null terminator"
        }
    }

    @tool[
        description: "Lists all files and subdirectories in a directory and returns the list",
        parameters: { path: "Directory path, must be an absolute path" }
    ]
    public func listDirectory(path: String): String {
        if (!Path(path).isAbsolute()) {
            return "Directory path must be absolute"
        }

        let message = path
        PrintUtils.printTool("List Directory", message)

        try {
            let (exitCode, stdOutData, stdErrData) = if (InfoUtils.os == "windows") {
                ShellUtils.execute(["dir"], workDir: Path(path))
            } else { //linux or ohos
                ShellUtils.execute(["ls", "-la"], workDir: Path(path))
            }

            if (exitCode == 0) {
                let outString = String.fromUtf8(stdOutData).trimAscii()
                return "Directory contents:\n${outString}"
            } else {
                let errString = String.fromUtf8(stdErrData).trimAscii()
                return "Failed to get directory contents, error output:\n${errString}"
            }
        } catch (e: Exception) {
            return "Failed to list directory: ${e}"
        }
    }

    @tool[
        description: "Reads and returns a specific range of lines from a file with line numbers. If startLine and endLine is omitted, the entire file will be read.",
        parameters: {
            filePath: "The absolute path to the file to read",
            startLine: "Optional: Starting line number (1-based, inclusive). If not provided, reads from start of file",
            endLine: "Optional: Ending line number (1-based, inclusive). If not provided, reads to end of file"
        }
    ]
    public func readFile(filePath: String, startLine: Option<Int64>, endLine: Option<Int64>): String {
        let start = startLine ?? 1
        let end = endLine.map { n => n.toString() } ?? "EOF"
        let message = "${filePath} (${start}-${end})"
        PrintUtils.printTool("Read File", message)

        let content = catRange(filePath, startLine ?? 1, endLine: endLine ?? Int64.Max)
        return "<file-content path=${filePath} start=${start} end=${end}>\n${content}\n</file-content>"
    }

    @tool[
        description: "Writes content to a single file and returns the write result",
        parameters: { filePath: "File path, must be an absolute path", content: "Content to write" }
    ]
    public func writeFile(filePath: String, content: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        let message = filePath + "\n" + content
        if (InputUtils.confirm("Write File", message) == Confirmation.Deny) {
            return "User denied the operation"
        }
        return writeFileBasic(filePath, content)
    }

    @tool[
        description: "${EDIT_FILE_DESCRIPTION}",
        parameters: {
            filePath: "File path, must be an absolute path",
            oldContent: "The exact literal text to replace, preferably unescaped. Including at least 3 lines of context BEFORE and AFTER the target text, matching whitespace and indentation precisely. If this string is not the exact literal text (i.e. you escaped it) or does not match exactly, the tool will fail.",
            newContent: "The exact literal text to replace `oldContent` with, preferably unescaped. Provide the EXACT text. newContent MUST be different from oldContent; otherwise, the tool will fail."
        }
    ]
    public func editFile(filePath: String, oldContent: String, newContent: String): String {
        if (!Path(filePath).isAbsolute()) {
            return "File path must be absolute"
        }

        try {
            let oldFileContent = String.fromUtf8(File.readFrom(filePath))

            if (!oldFileContent.contains(oldContent)) {
                // Ê£ÄÊü•ÊòØÂê¶Â≠òÂú®Êç¢Ë°åÁ¨¶‰∏çÂåπÈÖçÈóÆÈ¢ò
                let hint = " " + checkLineEndingMismatch(oldContent, oldFileContent)
                PrintUtils.printToolFailure(
                    "Edit File (${filePath})",
                    failureInfo: "File does not contain the specified content." + hint
                )
                return "Failed to edit. File ${filePath} does not contain the specified content '${oldContent}'." + hint
            }

            // ‰ΩøÁî®ÂéüÂßãÂÜÖÂÆπËøõË°åÊõøÊç¢
            let newFileContent = oldFileContent.replace(oldContent, newContent)
            if (oldFileContent == newFileContent) {
                PrintUtils.printToolFailure(
                    "Edit File (${filePath})",
                    failureInfo: "File content is not modified"
                )
                return "No changes to apply. The oldContent and newContent are identical in file: ${filePath}"
            }

            let message = diff(oldFileContent, newFileContent) |> PrintUtils.renderDiff

            if (InputUtils.confirm("Edit File (${filePath})", message) == Confirmation.Deny) {
                return "User denied the operation"
            }

            File.writeTo(filePath, newFileContent.toArray())
            return "File ${filePath} content modified successfully"
        } catch (ex: FSException) {
            return "File path error or file is not readable/writable"
        } catch (ex: IllegalArgumentException) {
            return "File path is empty or contains illegal characters"
        }
    }

    @tool[
        description: 'Searches for a regular expression pattern within the content of files in a specified directory (or current working directory). Can filter files by a glob pattern. Returns the lines containing matches, along with their file paths and line numbers.',
        parameters: {
            pattern: "The regular expression (regex) pattern to search for within file contents (e.g., 'func \\s+foo', 'import\\s+\\{.*\\}\\s+.*').",
            path: "Optional: The absolute path to the directory to search within. If omitted, searches the current working directory.",
            fileType: "Optional: A glob pattern to filter which files are searched (e.g., '*.js', '*.{ts,tsx}', 'src/**'). If omitted, searches all files (respecting potential global ignores).",
        }
    ]
    public func grepSearch(pattern: String, path: Option<String>, include: Option<String>): String {
        // Construct the info message
        let strBuilder = StringBuilder("pattern: ${pattern}")
        if (let Some(path) <- path) {
            strBuilder.append("\npath: ${path}")
        }
        if (let Some(include) <- include) {
            strBuilder.append("\ninclude: ${include}")
        }
        PrintUtils.printTool("Grep", strBuilder.toString())

        let result = grep(pattern, path, include)
        if (result.isEmpty()) {
            return "Nothing found"
        } else {
            return result
        }
    }

    // @tool[
    //     description: "Lists the directory structure recursively from the given path, showing files and subdirectories in a tree-like format. Useful for understanding the overall layout and hierarchy of a project or folder.",
    //     parameters: {
    //         path: "The absolute path to the directory to visualize."
    //     }
    // ]
    // public func tree(path: String): String {
    //     PrintUtils.printTool("Tree", "path: ${path}")
    //     return listTree(path)
    // }

    @tool[
        description: "Efficiently finds files matching specific extensions patterns (e.g., `src/**/*.ts`, `**/*.md`), returning absolute paths. Ideal for quickly locating files based on their extension name, especially in large codebases.",
        parameters: {
            pattern: "Glob pattern to match (e.g., '*.cj' for Cangjie files, '**/test*.cj' for test files recursively)",
            path: "Optional: absolute directory path to search in. Defaults to current working directory."
        }
    ]
    public func globSearch(pattern: String, path: Option<String>): String {
        let searchPath = path ?? CliConfig.cwd.toString()
        if (!Path(searchPath).isAbsolute()) {
            return "Path must be absolute"
        }
        if (!exists(searchPath)) {
            return "Path does not exist: ${searchPath}"
        }

        let message = "pattern: ${pattern}\npath: ${searchPath}"
        PrintUtils.printTool("Glob Search", message)

        try {
            let results = glob(pattern, searchPath)

            if (results.isEmpty()) {
                return "No files matching pattern '${pattern}' found"
            }

            let strBuilder = StringBuilder("Found ${results.size} matches:\n")
            for (file in results) {
                strBuilder.append("- ${file}\n")
            }
            return strBuilder.toString()
        } catch (e: Exception) {
            return "Error during glob search: ${e}"
        }
    }

    @tool[
        description: "Returns the first N lines of a file with line numbers. Useful for quickly inspecting the beginning of large files without loading the entire content.",
        parameters: {
            filePath: "The absolute path to the file to read",
            lines: "Optional: Number of lines to return (defaults to 10)"
        }
    ]
    public func headFile(filePath: String, lines: Option<Int64>): String {
        let message = "filePath: ${filePath}\nlines: ${lines.map { n => n.toString() } ?? "10 (default)"}"
        PrintUtils.printTool("Head", message)

        return head(filePath, lines: lines ?? 10)
    }

    /**
     * üöÄ P0-1: ÊâπÈáèÂπ∂Ë°åËØªÂèñÂ§ö‰∏™Êñá‰ª∂ÔºàÁúüÂÆûÂÆûÁé∞Ôºâ
     *
     * Ëá™Âä®‰ΩøÁî®Âπ∂Ë°åÊâßË°åËØªÂèñÂ§ö‰∏™Êñá‰ª∂ÔºåÊèêÂçáÊÄßËÉΩ
     *
     * @param filePaths Êñá‰ª∂Ë∑ØÂæÑÊï∞ÁªÑ
     * @return Êñá‰ª∂ÂÜÖÂÆπÊï∞ÁªÑÔºà‰∏éËæìÂÖ•È°∫Â∫èÂØπÂ∫îÔºâ
     *
     * ÊÄßËÉΩÔºö
     * - ‰∏≤Ë°å: n‰∏™Êñá‰ª∂ √ó 50ms = n√ó50ms
     * - Âπ∂Ë°å: max(50ms) √ó (n/4) ‚âà n√ó12.5ms
     * - Âä†ÈÄüÊØî: Á∫¶4xÔºàÂ∞èÊñá‰ª∂ÔºâÂà∞2xÔºàÂ§ßÊñá‰ª∂Ôºâ
     */
    @tool[
        description: """
üöÄ Batch read multiple files in parallel for maximum performance (2-4x faster than sequential reading).

This tool uses parallel execution (MAX_CONCURRENCY=4) to read multiple files simultaneously.

Use cases:
- Read configuration files at startup
- Load multiple source files for analysis
- Batch data processing

Performance:
- Small files (< 100KB): 4x faster
- Large files (> 1MB): 2x faster
- Recommended for 3+ files

Example usage:
- "‰ΩøÁî®batchReadFilesÊâπÈáèËØªÂèñ‰ª•‰∏ã6‰∏™Êñá‰ª∂Ôºö/path/to/file1.cj,/path/to/file2.cj,/path/to/file3.cj"
- "Read all config files: /project/config.toml,/project/settings.toml"

Returns: JSON object with file contents, status, and performance metrics.
""",
        parameters: {
            filePaths: "Comma-separated absolute file paths (e.g., '/path/file1.txt,/path/file2.txt'). Spaces around commas are trimmed automatically."
        }
    ]
    public func batchReadFiles(filePaths: String): String {
        // Ëß£ÊûêÊñá‰ª∂Ë∑ØÂæÑÂàóË°®
        let cleanPaths = filePaths.split(",") |>
            map { path => path.trimAscii() } |>
            filter { path => !path.isEmpty() } |>
            collectArray

        let message = String.join(cleanPaths, delimiter: "\n")
        PrintUtils.printTool("Batch Read Files", message)

        // Validate input
        if (cleanPaths.isEmpty()) {
            let errorResult = HashMap<String, JsonValue>()
            errorResult["error"] = JsonString("No file paths provided")
            errorResult["files"] = JsonArray([])
            return JsonObject(errorResult).toJsonString()
        }

        let totalFiles = cleanPaths.size

        let startMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
        LogUtils.info("[FSToolset] Batch reading ${totalFiles} files in parallel...")

        let results = ArrayList<Option<String>>(totalFiles, { i => None })

        // ÂàÜÊâπÂπ∂ÂèëÂ§ÑÁêÜÔºàÊúÄÂ§ö4‰∏™Âπ∂ÂèëÔºâ
        let MAX_CONCURRENCY = 4
        for (index in 0..totalFiles:MAX_CONCURRENCY) {
            let batchEnd = if (index + MAX_CONCURRENCY < totalFiles) {
                index + MAX_CONCURRENCY
            } else {
                totalFiles
            }
            let batchSize = batchEnd - index

            // ÂΩìÂâçÊâπÊ¨°ÁöÑÂπ∂ÂèëÊâßË°å
            let futures = ArrayList<Future<(Int64, String)>>()

            for (fileIndex in index..batchEnd) {
                let filePath = cleanPaths[fileIndex]
                let fut = spawn {
                    try {
                        let content = String.fromUtf8(File.readFrom(filePath))
                        LogUtils.debug("[FSToolset] Parallel read: ${filePath} (${content.size} bytes)")
                        return (fileIndex, content)
                    } catch (e: Exception) {
                        LogUtils.error("[FSToolset] Failed to read ${filePath}: ${e.message}")
                        return (fileIndex, "Error reading ${filePath}: ${e.message}")
                    }
                }
                futures.add(fut)
            }
            // Á≠âÂæÖÂΩìÂâçÊâπÊ¨°ÂÆåÊàê
            for (fut in futures) {
                let (fileIndex, content) = fut.get()
                results[fileIndex] = content
            }
        }

        // ËΩ¨Êç¢ÁªìÊûú‰∏∫JSONÊ†ºÂºè
        let fileResults = ArrayList<JsonValue>()
        var successCount: Int64 = 0

        for (i in 0..totalFiles) {
            let filePath = cleanPaths[i]
            let fileResult = HashMap<String, JsonValue>()
            fileResult["path"] = JsonString(filePath)

            if (let Some(content) <- results[i]) {
                if (content.startsWith("Error reading")) {
                    fileResult["status"] = JsonString("error")
                    fileResult["error"] = JsonString(content)
                } else {
                    fileResult["status"] = JsonString("success")
                    fileResult["content"] = JsonString(content)
                    fileResult["size"] = JsonInt(Int64(content.size))
                    successCount += 1
                }
            } else {
                fileResult["status"] = JsonString("error")
                fileResult["error"] = JsonString("Failed to read file")
            }

            fileResults.add(JsonObject(fileResult))
        }

        let endMs = DateTime.now().toUnixTimeStamp().toMilliseconds()
        let durationMs = endMs - startMs
        LogUtils.info("[FSToolset] ‚ö° Batch read completed: ${successCount}/${totalFiles} files in ${durationMs}ms")

        // ÊûÑÂª∫ÊúÄÁªàJSONÁªìÊûú
        let result = HashMap<String, JsonValue>()
        result["files"] = JsonArray(fileResults.toArray())
        result["totalFiles"] = JsonInt(totalFiles)
        result["successCount"] = JsonInt(successCount)
        result["failedCount"] = JsonInt(totalFiles - successCount)
        result["durationMs"] = JsonInt(durationMs)

        return JsonObject(result).toJsonString()
    }
}